[["CMake实践记录","2023年01月01日","/2023/01/10/cmake%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95.html/","作为一门比shell的语法还x疼的“语言”，不动动笔杆子真不行。 以下基本以flameshot\r为例来学习。 覆盖掉CMakeCache中缓存的option\r不推荐使用 `，因为更改option状态时会被CMakeCache里的旧Option状态覆盖，且对subdirectory内的CMakeLists.txt作用效果不好。 推荐做法： `： OPTION_NAME：option名称。 OPTION_STATE：option状态，一般为 `，推荐使用全大写。 CACHE：表示写入到CMakeCache里。 FORCE：表示强制覆盖CMakeCache里的值。 CMakeLists.txt内添加编译时变量\r语法： ` 例如MSVC开启强制utf-8： 题外话，对应的在QMake内开启的方法为在 `内添加： 添加宏（MARCO）\r语法： ` 相当于编译时有了宏MARCO_NAME。 那么如何把宏去掉呢？ ` include、output、link的顺序\r先 `。 CMake使用Qt5库\r需要按以下几步走。 打开额外Compiler开关\r分别编译Qt的元对象系统（信号槽，或者说使用了 `。 设定CMake的Modules\r在尽量开头的位置设置 `到Qt自带的cmake目录，如： ` 实际操作过程中推荐这样写： ` 并在执行 `下： ` （Windows下，使用QtCreator不需要 `） 检查Qt库(CMake modules)的安装情况\r以使用QtCore、QtGui、QtWidgets为例，设定了 `后： ` PS：似乎还有一种语法： ` 链接Qt动态库\r基本在最后位置： ` 上面的语句默认链接debug版本的动态库，若要链接release版本，增加 ` ` 包含子目录\r在上层目录中，首先 ` 在子目录 ` target_sources的用法\r`（前提是相关Compiler已打开）。 区分系统平台\r立即推： QtCreator中could not load cache的解决方法\r可怜的qtc，bug满身，对Qml而言是，对CMake更是。 现在还坚持用qtc的原因只有方便看文档和上色丰富简单又好看了吧。 清除-重新构建后总是报错：could not load cache怎么办？ 找到左边项目-CMake- `，点一下即可重新编译。 Windows平台rc文件的使用\r使用 `添加即可。 注意：编码格式在设置了UTF-8以后无比不要用UTF-8-BOM，否则在编译时会报错。 关于 `文件的格式，参考flameshot.rc\rWindows平台关闭控制台\r使用 `参数： ` 解决Cannot find source file: main.cpp\r目录结构如下： CMakeLists一层一层add_subdirectory。 `时报错：Cannot find source file: main.cpp。 意外发现将CMake最低要求版本 `设置到\u0026gt;=3.13，qtc默认给的是3.5。 题外话：直接在文件夹里cmake .没有这个报错，所以……彩鸡qtc。 "],["配置neovim","2023年01月01日","/2023/01/09/%E9%85%8D%E7%BD%AEneovim.html/","\r配置neovim\rneovim\r是一款强大且轻量的基于vim的tui编辑器，相比vim有更现代的设置和插件系统。今天neovim的生态已然非常广泛。 安装neovim\rLinux\rneovim release page\r上提供了*.deb和*.tar.gz，安装非常方便。 不推荐通过 `等包管理软件安装neovim，版本太老。 Windows\rrelease page上提供了Windows可用的*.zip，使用Qt制作了GUI。 然而GUI太不vim了，想在Linux的shell里使用vim怎么办？可以采用wezterm + msys2 + 从源码编译neovim的组合技，可以复刻Linux shell中90%的操作。 编译方法见neovim wiki\r，大概命令如下： 亲测在Win10上一次编过，编完以后neovim的二进制会install到shell启动默认目录下的nvim-win64/bin内。找不到的话用Everything找一下就行了。加到PATH里即可顺利玩耍。 关于neovim插件\rSTOP！我说停停，到这里解释一下neovim插件相关的概念，为啥呢？网上教装插件的教程不少，但可能是我太笨吧，看完了也看得云里雾里，包括原生vim的插件也是很迷。 (neo)vim的插件\r插件指的是给(neo)vim提供额外功能的“软件”，一般是vimscript（适用于vim）和lua（适用于neovim）编写的，这两种都是脚本语言，下载插件也就是下载源码，一般从github上克隆到指定目录即可。 neovim也可以使用vimscript制作的插件，但是vimscript的效率比较低，装多了卡，而且远不如lua好理解，哪怕一点也不懂lua（比如我），看一看也能照猫画虎写，不推荐在neovim里用太多vimscript编写的插件。 (neo)vim的插件管理器\r插件管理器是指提供下载插件、管理插件加载的特殊插件，一般也是从github上安装，直接 `下来就行。 vim-plug\r是一款插件管理器，可以用于vim和neovim。在vim上算最好用的插件，但是在neovim里并不推荐，因为它用的是vimscript，和满处lua的neovim有点格格不入。 packer.vim\r也是一款插件管理器，可以用于neovim，采用lua编写，配置的可读性强，好上手，neovim上首推。 安装neovim插件\r安装packer.vim\r先安装插件管理器才方便装插件嘛，直接进行一个命令行的装： 至此，packer安装完成，那么如何通过它管理插件呢？ Linux上neovim会从 `读取配置，用lua写配置就是前者的路径了。 实际上配置路径好像很多，但是用这两个就行。 Windows的配置文件路径以后会补充，现在可以去官网看 先进到 `的文件夹，用来存放我们将要写的lua脚本。 把它想象成“项目根目录”，比如： 我写了一个 `。 没有这个文件夹就自己建一个。 看过一些neovim配置示例，按惯例： `，举个例子：\r`）加载vim基本配置，举个栗子： 相当于vim的 `里的： 不能说一模一样，只能说完全相同。 `）里面写想加载的插件及其配置，还是举例子： 写好配置了，然后怎么安装呢？ 运行 `即可自动从github上下载插件并把旧插件升到最新版本。 安装LSP\rneovim安装LSP比较方便，LSP是指\u0026quot;Language Server Protocol\u0026quot;，虽然是协议，可以理解为一种在后台进行静态代码分析的server，提供显示代码错误、代码补全建议的功能，非常好用。 Idea、VS Code太重了，难道我写个demo还要打开这些笨蛋看着内存疯狂上涨吗？ 如果把vim和LSP结合在一起，岂不是双倍快乐？大项目不谈，写个小demo又会带来更多快乐。 neovim可以安装LSP，vim也可以，可惜后者似乎安装有些麻烦，还是前者吧，这也是我想从vim转到neovim的原因之一。 LSP插件组成\r虽然叫LSP插件组成，这里实际是想讲整个LSP套件的组成，需要哪些插件。 LSP Server：刚才说了，我们想要的显示代码错误、代码补全建议的功能就是它提供的。 需要指出的是，不同的语言需要启用不同的LSP，比如C/CPP可以用Clangd，Go可以用gopls，Rust可以用rust-analyzer，Python可以用pyright。 需要安装。 LSP Client：大概是处理Server发来的信息呗，这部分不用管，neovim自带整个功能。 不需要安装。 LSP Server管理器：一个neovim插件，可以方便的管理各种LSP Server。 需要安装。 LSP Server下载器：neovim\u0026rsquo;插件，提供下载LSP Server功能。 需要安装。 代码补全建议插件：neovim不带这部分，LSP Server也不包含这部分，所以需要额外下一个neovim插件： 需要安装。 放到今天的示例里，对应关系为： LSP Server：按需下载，列表在nvim-lspconfig的文档\r。 LSP Server管理器：nvim-lspconfig\r。 LSP Server下载器：mason.vim\r。 代码补全建议插件：nvim-cmp\r。 最后提供一个示例：realth000/config\r"],["Hello_hugo","2023年01月01日","/2023/01/09/hello_hugo.html/","Hello Hugo"],["","0001年01月01日","/1/01/01/.html/","\r[CMake] CMake实践记录\r作为一门比shell的语法还x疼的“语言”，不动动笔杆子真不行。 以下基本以flameshot\r为例来学习。 覆盖掉CMakeCache中缓存的option\r不推荐使用 `，因为更改option状态时会被CMakeCache里的旧Option状态覆盖，且对subdirectory内的CMakeLists.txt作用效果不好。 推荐做法： `： OPTION_NAME：option名称。 OPTION_STATE：option状态，一般为 `，推荐使用全大写。 CACHE：表示写入到CMakeCache里。 FORCE：表示强制覆盖CMakeCache里的值。 CMakeLists.txt内添加编译时变量\r语法： ` 例如MSVC开启强制utf-8： 题外话，对应的在QMake内开启的方法为在 `内添加： 添加宏（MARCO）\r语法： ` 相当于编译时有了宏MARCO_NAME。 那么如何把宏去掉呢？ ` include、output、link的顺序\r先 `。 CMake使用Qt5库\r需要按以下几步走。 打开额外Compiler开关\r分别编译Qt的元对象系统（信号槽，或者说使用了 `。 设定CMake的Modules\r在尽量开头的位置设置 `到Qt自带的cmake目录，如： ` 实际操作过程中推荐这样写： ` 并在执行 `下： ` （Windows下，使用QtCreator不需要 `） 检查Qt库(CMake modules)的安装情况\r以使用QtCore、QtGui、QtWidgets为例，设定了 `后： ` PS：似乎还有一种语法： ` 链接Qt动态库\r基本在最后位置： ` 上面的语句默认链接debug版本的动态库，若要链接release版本，增加 ` ` 包含子目录\r在上层目录中，首先 ` 在子目录 ` target_sources的用法\r`（前提是相关Compiler已打开）。\r区分系统平台\r立即推： QtCreator中could not load cache的解决方法\r可怜的qtc，bug满身，对Qml而言是，对CMake更是。 现在还坚持用qtc的原因只有方便看文档和上色丰富简单又好看了吧。 清除-重新构建后总是报错：could not load cache怎么办？ 找到左边项目-CMake- `，点一下即可重新编译。 Windows平台rc文件的使用\r使用 `添加即可。 注意：编码格式在设置了UTF-8以后无比不要用UTF-8-BOM，否则在编译时会报错。 关于 `文件的格式，参考flameshot.rc\rWindows平台关闭控制台\r使用 `参数： ` 解决Cannot find source file: main.cpp\r目录结构如下： CMakeLists一层一层add_subdirectory。 `时报错：Cannot find source file: main.cpp。 意外发现将CMake最低要求版本 `设置到\u0026gt;=3.13，qtc默认给的是3.5。 题外话：直接在文件夹里cmake .没有这个报错，所以……彩鸡qtc。 "]]