[["智能的命令","2023年01月01日","/en-us/2023/01/20/%E6%99%BA%E8%83%BD%E7%9A%84%E5%91%BD%E4%BB%A4.html/"," 智能的命令也不会遇到兔女郎学姐。 智能 智能的命令会给使用者带来更好的体验，比如不小心输入错参数时可以提示相似的正确参数、提供更易用的参数等等。举个例子： git 那么git是怎么做的呢？源码面前，了无秘密，直接一手clone: 1 git clone https://github.com/git/git.git --depth=1 然后 `： 1 2 3 cd git cd po nvim zh_CN.po 搜索 `函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # po/zh_CN.po 3 #: help.c 2 #, c-format 1 msgid \u0026#34;git: \u0026#39;%s\u0026#39; is not a git command. See \u0026#39;git --help\u0026#39;.\u0026#34; 20201 msgstr \u0026#34;git：\u0026#39;%s\u0026#39; 不是一个 git 命令。参见 \u0026#39;git --help\u0026#39;。\u0026#34; # help.c 597 const char *help_unknown_cmd(const char *cmd) 1 { ... 17 18 if (autocorrect == AUTOCORRECT_NEVER) { 19 fprintf_ln(stderr, _(\u0026#34;git: \u0026#39;%s\u0026#39; is not a git command. See \u0026#39;git --help\u0026#39; .\u0026#34;), cmd); 20 exit(1); 21 } 用 `文件夹里，八成不是，先忽略。查看另一处调用的位置。 1 2 3 4 5 6 7 8 9 10 11 12 ✿ grep -rn help_unknown_cmd help.c:597:const char *help_unknown_cmd(const char *cmd) git.c:909: cmd = argv[0] = help_unknown_cmd(cmd); builtin/help.c:589: return help_unknown_cmd(cmd); help.h:33:const char *help_unknown_cmd(const char *cmd); # git.c 1 if (!done_help) { 909 cmd = argv[0] = help_unknown_cmd(cmd); 1 done_help = 1; 2 } else 3 break; 好像不太对，直接找刚才的提示吧。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ✿ grep -rn -a5 \u0026#34;最相似\u0026#34; po/zh_CN.po-20231-msgid_plural \u0026#34;\u0026#34; po/zh_CN.po-20232-\u0026#34;\\n\u0026#34; po/zh_CN.po-20233-\u0026#34;The most similar commands are\u0026#34; po/zh_CN.po-20234-msgstr[0] \u0026#34;\u0026#34; po/zh_CN.po-20235-\u0026#34;\\n\u0026#34; po/zh_CN.po:20236:\u0026#34;最相似的命令是\u0026#34; po/zh_CN.po-20237-msgstr[1] \u0026#34;\u0026#34; po/zh_CN.po-20238-\u0026#34;\\n\u0026#34; po/zh_CN.po:20239:\u0026#34;最相似的命令是\u0026#34; po/zh_CN.po-20240- po/zh_CN.po-20241-#: help.c po/zh_CN.po-20242-msgid \u0026#34;git version [--build-options]\u0026#34; po/zh_CN.po-20243-msgstr \u0026#34;git version [--build-options]\u0026#34; po/zh_CN.po-20244- ✿ grep -rn \u0026#39;The most similar commands ar\u0026#39; *.c help.c:718: \u0026#34;\\nThe most similar commands are\u0026#34;, 还是 `里，打开看： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /* This abuses cmdname-\u0026gt;len for levenshtein distance */ for (i = 0, n = 0; i \u0026lt; main_cmds.cnt; i++) { int cmp = 0; /* avoid compiler stupidity */ const char *candidate = main_cmds.names[i]-\u0026gt;name; /* * An exact match means we have the command, but * for some reason exec\u0026#39;ing it gave us ENOENT; probably * it\u0026#39;s a bad interpreter in the #! line. */ if (!strcmp(candidate, cmd)) die(_(bad_interpreter_advice), cmd, cmd); /* Does the candidate appear in common_cmds list? */ while (common_cmds[n].name \u0026amp;\u0026amp; (cmp = strcmp(common_cmds[n].name, candidate)) \u0026lt; 0) n++; if (common_cmds[n].name \u0026amp;\u0026amp; !cmp) { /* Yes, this is one of the common commands */ n++; /* use the entry from common_cmds[] */ if (starts_with(candidate, cmd)) { /* Give prefix match a very good score */ main_cmds.names[i]-\u0026gt;len = 0; continue; } } main_cmds.names[i]-\u0026gt;len = levenshtein(cmd, candidate, 0, 2, 1, 3) + 1; } FREE_AND_NULL(common_cmds); QSORT(main_cmds.names, main_cmds.cnt, levenshtein_compare); if (!main_cmds.cnt) die(_(\u0026#34;Uh oh. Your system reports no Git commands at all.\u0026#34;)); /* skip and count prefix matches */ for (n = 0; n \u0026lt; main_cmds.cnt \u0026amp;\u0026amp; !main_cmds.names[n]-\u0026gt;len; n++) ; /* still counting */ if (main_cmds.cnt \u0026lt;= n) { /* prefix matches with everything? that is too ambiguous */ best_similarity = SIMILARITY_FLOOR + 1; } else { /* count all the most similar ones */ for (best_similarity = main_cmds.names[n++]-\u0026gt;len; (n \u0026lt; main_cmds.cnt \u0026amp;\u0026amp; best_similarity == main_cmds.names[n]-\u0026gt;len); n++) ; /* still counting */ } if (autocorrect \u0026amp;\u0026amp; n == 1 \u0026amp;\u0026amp; SIMILAR_ENOUGH(best_similarity)) { const char *assumed = main_cmds.names[0]-\u0026gt;name; main_cmds.names[0] = NULL; clean_cmdnames(\u0026amp;main_cmds); fprintf_ln(stderr, _(\u0026#34;WARNING: You called a Git command named \u0026#39;%s\u0026#39;, \u0026#34; \u0026#34;which does not exist.\u0026#34;), cmd); if (autocorrect == AUTOCORRECT_IMMEDIATELY) fprintf_ln(stderr, _(\u0026#34;Continuing under the assumption that \u0026#34; \u0026#34;you meant \u0026#39;%s\u0026#39;.\u0026#34;), assumed); else if (autocorrect == AUTOCORRECT_PROMPT) { char *answer; struct strbuf msg = STRBUF_INIT; strbuf_addf(\u0026amp;msg, _(\u0026#34;Run \u0026#39;%s\u0026#39; instead [y/N]? \u0026#34;), assumed); answer = git_prompt(msg.buf, PROMPT_ECHO); strbuf_release(\u0026amp;msg); if (!(starts_with(answer, \u0026#34;y\u0026#34;) || starts_with(answer, \u0026#34;Y\u0026#34;))) exit(1); } else { fprintf_ln(stderr, _(\u0026#34;Continuing in %0.1f seconds, \u0026#34; \u0026#34;assuming that you meant \u0026#39;%s\u0026#39;.\u0026#34;), (float)autocorrect/10.0, assumed); sleep_millisec(autocorrect * 100); } return assumed; } fprintf_ln(stderr, _(\u0026#34;git: \u0026#39;%s\u0026#39; is not a git command. See \u0026#39;git --help\u0026#39;.\u0026#34;), cmd); if (SIMILAR_ENOUGH(best_similarity)) { fprintf_ln(stderr, Q_(\u0026#34;\\nThe most similar command is\u0026#34;, \u0026#34;\\nThe most similar commands are\u0026#34;, n)); for (i = 0; i \u0026lt; n; i++) fprintf(stderr, \u0026#34;\\t%s\\n\u0026#34;, main_cmds.names[i]-\u0026gt;name); } exit(1); 似乎有点长，有个关键词：levenshtein distance，算半个老朋友嘛how old are you?。 我记得，用一句话概括这个算法就是： 有两个字符串A和B，每次只增加/删除/修改A的一个字（或者字母，标点符号），需要多少次能把A改成B，这个次数就是A和B之间的距离。 `时使用的index。 先手动查，如果是已知命令，那就把对应距离改成0。否则计算逻辑距离。 计算逻辑距离： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # levenshtein.c int levenshtein(const char *string1, const char *string2, int w, int s, int a, int d) { int len1 = strlen(string1), len2 = strlen(string2); int *row0, *row1, *row2; int i, j; ALLOC_ARRAY(row0, len2 + 1); ALLOC_ARRAY(row1, len2 + 1); ALLOC_ARRAY(row2, len2 + 1); for (j = 0; j \u0026lt;= len2; j++) row1[j] = j * a; for (i = 0; i \u0026lt; len1; i++) { int *dummy; row2[0] = (i + 1) * d; for (j = 0; j \u0026lt; len2; j++) { /* substitution */ row2[j + 1] = row1[j] + s * (string1[i] != string2[j]); /* swap */ if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0 \u0026amp;\u0026amp; string1[i - 1] == string2[j] \u0026amp;\u0026amp; string1[i] == string2[j - 1] \u0026amp;\u0026amp; row2[j + 1] \u0026gt; row0[j - 1] + w) row2[j + 1] = row0[j - 1] + w; /* deletion */ if (row2[j + 1] \u0026gt; row1[j + 1] + d) row2[j + 1] = row1[j + 1] + d; /* insertion */ if (row2[j + 1] \u0026gt; row2[j] + a) row2[j + 1] = row2[j] + a; } dummy = row0; row0 = row1; row1 = row2; row2 = dummy; } i = row1[len2]; free(row0); free(row1); free(row2); return i; } 记录一下，以后可以借鉴（不是）。 shutdown 我记得 `这种单词，刚才试了试怎么不认识。不能是我记错了吧？ 查了查似乎 `命令可以这样玩，下次再写吧。 一定是我太困了，该睡了，晚安。 "],["Qt多语言翻译（国际化）","2023年01月01日","/en-us/2023/01/12/qt%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91%E5%9B%BD%E9%99%85%E5%8C%96.html/","如果想支持多语言，也就是添加翻译，需要使用qlinguist相关的内容。 在qt中实现的大体流程为：根据源代码生成 `文件（翻译文件）。 源码中所有希望添加进翻译文件的字符串都需要使用 `包裹。 由于与涉及到不同的build system以及 `文件的加载方式，具体的实现方法非常乱。 梳理花了很大一番功夫。 以下学习过程基于flameshot 和qBittorrent 两个项目。 由于缺包等原因，我本地的环境没法编译qBittorrent工程，仅看源码来学习。 实现方式 翻译文件的加载方式 在翻译文件 `的加载方式上，有两个选择： 可以选择把文件单独放到一个文件夹（如 `）。 也可以选择放进资源文件 `）。 前者的好处是翻译文件独立，修改翻译文件时不需要重新编译程序，坏处是翻译文件暴露在外，可能会遇到丢失、乱码等情况。更常见的情况是修改并生成文件后，忘了把新版的文件放到 `文件夹里。 后者的好处是可以使用qrc资源系统控制，不暴露在外，只要重新生成即可不需要手动放到translation文件夹，坏处是一旦修改文件就需要重新编译程序，而且包含所有翻译语言的翻译文件的话程序体积会略微大一点。 两套构建系统对翻译文件的处理 CMake 在CMake里，如果想加载翻译文件，需要 `模块： 幸运的是 `模块不是一个单独的动态库，应该是包含在Qt5Core内的。 生成并加载翻译文件需要使用 `打开。 QMake QMake需要使用Qt的 `文件，其实CMake底层也是调用的这个工具。 加载翻译文件需要用INSTALLATIONS变量 += 上所有的 `文件。 希望尽可能的自动化 编译过程需要手动操作的话非常恶星，总是希望整个构建过程能自动化就自动化。 需要自动化的点有： 自动根据 `。 自动加载 `能自动放在需要它的位置上，同时还包括程序加载翻译文件时选择当前系统语言。当然也可以加一个选择语言的配置，但能够选择性的加载翻译文件同样是必须的。 两个示例项目做了什么 flameshot flameshot 只支持CMake构建，对翻译文件的整个处理也比较简单。 在 `： 紧接着生成翻译文件： 根据 `本身只是一个手动控制的开关： 最后安装翻译文件到指定位置： 加载翻译文件的方式如下： 用了两个translator，一个加载Qt自带语句的翻译，一个是加载项目自己加入的需要的翻译。 qBittorrent qBittorrent 同时支持使用QMake和Cmake构建，对翻译的处理较为复杂。 CMake 在 `文件并生成翻译文件： `是qBittorrent自定义的一个函数，反正非常复杂就对了，杀鸡焉用牛刀，撤。 QMake 在 `中，仅有以下几行代码即可： 最前面的一个大的if来设定生成翻译文件所用的 `两个变量。 非常简单明了。 最终实现 选择的实现方法 尽量想同时用QMake和CMake支持加载翻译文件，毕竟QMake有时候还挺好用，你Qt6的QMake停止更新关我Qt5的用户什么事。 选择将翻译文件放到 `文件里写自定义命令的方式安装到translation文件夹里，调用起来也麻烦。 预备工作 首次生成翻译文件时，我们是连 `： 在源码里配置好想加入翻译文件的文本，包括 `包裹。 在 `文件里加上qBittorrent里翻译文件相关的配置 打开Qt自带的命令行，在这个命令行里才能用 `一下就行）。 使用 `。 用文本编辑器打开 `。 在打开刚出的命令行，用 `。 新建一个qrc文件（如 `也可以加进去，不加也行但要记得加进git仓库。 CMake 在有 `添加进编译的目标程序内（格式不支持）： 注意： 以上语句需要在 `添加了qrc文件之前。 `设置的输出目录必须是qrc文件内记录的qm文件目录，否则生成时无法更新qrc文件内包含的翻译。 之后在 `时加上生成的翻译文件： 别忘了讲qrc文件加进来，并且打开AUTORCC开关： QMake `文件里加入以下配置： 完事了，非常简单。 加载翻译文件 在 `之前，一般在main.cpp里： 我只制作了中文和英文两种翻译所以switch只有两条分支。 `需要在声明application之后。 "],["CMake实践记录","2023年01月01日","/en-us/2023/01/10/cmake%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95.html/","作为一门比shell的语法还x疼的“语言”，不动动笔杆子真不行。 以下基本以flameshot 为例来学习。 覆盖掉CMakeCache中缓存的option 不推荐使用 `，因为更改option状态时会被CMakeCache里的旧Option状态覆盖，且对subdirectory内的CMakeLists.txt作用效果不好。 推荐做法： `： OPTION_NAME：option名称。 OPTION_STATE：option状态，一般为 `，推荐使用全大写。 CACHE：表示写入到CMakeCache里。 FORCE：表示强制覆盖CMakeCache里的值。 CMakeLists.txt内添加编译时变量 语法： ` 例如MSVC开启强制utf-8： 题外话，对应的在QMake内开启的方法为在 `内添加： 添加宏（MARCO） 语法： ` 相当于编译时有了宏MARCO_NAME。 那么如何把宏去掉呢？ ` include、output、link的顺序 先 `。 CMake使用Qt5库 需要按以下几步走。 打开额外Compiler开关 分别编译Qt的元对象系统（信号槽，或者说使用了 `。 设定CMake的Modules 在尽量开头的位置设置 `到Qt自带的cmake目录，如： ` 实际操作过程中推荐这样写： ` 并在执行 `下： ` （Windows下，使用QtCreator不需要 `） 检查Qt库(CMake modules)的安装情况 以使用QtCore、QtGui、QtWidgets为例，设定了 `后： ` PS：似乎还有一种语法： ` 链接Qt动态库 基本在最后位置： ` 上面的语句默认链接debug版本的动态库，若要链接release版本，增加 ` ` 包含子目录 在上层目录中，首先 ` 在子目录 ` target_sources的用法 `（前提是相关Compiler已打开）。 区分系统平台 立即推： QtCreator中could not load cache的解决方法 可怜的qtc，bug满身，对Qml而言是，对CMake更是。 现在还坚持用qtc的原因只有方便看文档和上色丰富简单又好看了吧。 清除-重新构建后总是报错：could not load cache怎么办？ 找到左边项目-CMake- `，点一下即可重新编译。 Windows平台rc文件的使用 使用 `添加即可。 注意：编码格式在设置了UTF-8以后无比不要用UTF-8-BOM，否则在编译时会报错。 关于 `文件的格式，参考flameshot.rc Windows平台关闭控制台 使用 `参数： ` 解决Cannot find source file: main.cpp 目录结构如下： CMakeLists一层一层add_subdirectory。 `时报错：Cannot find source file: main.cpp。 意外发现将CMake最低要求版本 `设置到\u0026gt;=3.13，qtc默认给的是3.5。 题外话：直接在文件夹里cmake .没有这个报错，所以……彩鸡qtc。 "],["配置neovim","2023年01月01日","/en-us/2023/01/09/%E9%85%8D%E7%BD%AEneovim.html/"," 配置neovim neovim 是一款强大且轻量的基于vim的tui编辑器，相比vim有更现代的设置和插件系统。今天neovim的生态已然非常广泛。 安装neovim Linux neovim release page 上提供了*.deb和*.tar.gz，安装非常方便。 不推荐通过 `等包管理软件安装neovim，版本太老。 Windows release page上提供了Windows可用的*.zip，使用Qt制作了GUI。 然而GUI太不vim了，想在Linux的shell里使用vim怎么办？可以采用wezterm + msys2 + 从源码编译neovim的组合技，可以复刻Linux shell中90%的操作。 编译方法见neovim wiki ，大概命令如下： 亲测在Win10上一次编过，编完以后neovim的二进制会install到shell启动默认目录下的nvim-win64/bin内。找不到的话用Everything找一下就行了。加到PATH里即可顺利玩耍。 关于neovim插件 STOP！我说停停，到这里解释一下neovim插件相关的概念，为啥呢？网上教装插件的教程不少，但可能是我太笨吧，看完了也看得云里雾里，包括原生vim的插件也是很迷。 (neo)vim的插件 插件指的是给(neo)vim提供额外功能的“软件”，一般是vimscript（适用于vim）和lua（适用于neovim）编写的，这两种都是脚本语言，下载插件也就是下载源码，一般从github上克隆到指定目录即可。 neovim也可以使用vimscript制作的插件，但是vimscript的效率比较低，装多了卡，而且远不如lua好理解，哪怕一点也不懂lua（比如我），看一看也能照猫画虎写，不推荐在neovim里用太多vimscript编写的插件。 (neo)vim的插件管理器 插件管理器是指提供下载插件、管理插件加载的特殊插件，一般也是从github上安装，直接 `下来就行。 vim-plug 是一款插件管理器，可以用于vim和neovim。在vim上算最好用的插件，但是在neovim里并不推荐，因为它用的是vimscript，和满处lua的neovim有点格格不入。 packer.vim 也是一款插件管理器，可以用于neovim，采用lua编写，配置的可读性强，好上手，neovim上首推。 安装neovim插件 安装packer.vim 先安装插件管理器才方便装插件嘛，直接进行一个命令行的装： 至此，packer安装完成，那么如何通过它管理插件呢？ Linux上neovim会从 `读取配置，用lua写配置就是前者的路径了。 实际上配置路径好像很多，但是用这两个就行。 Windows的配置文件路径以后会补充，现在可以去官网看 先进到 `的文件夹，用来存放我们将要写的lua脚本。 把它想象成“项目根目录”，比如： 我写了一个 `。 没有这个文件夹就自己建一个。 看过一些neovim配置示例，按惯例： `，举个例子： `）加载vim基本配置，举个栗子： 相当于vim的 `里的： 不能说一模一样，只能说完全相同。 `）里面写想加载的插件及其配置，还是举例子： 写好配置了，然后怎么安装呢？ 运行 `即可自动从github上下载插件并把旧插件升到最新版本。 安装LSP neovim安装LSP比较方便，LSP是指\u0026quot;Language Server Protocol\u0026quot;，虽然是协议，可以理解为一种在后台进行静态代码分析的server，提供显示代码错误、代码补全建议的功能，非常好用。 Idea、VS Code太重了，难道我写个demo还要打开这些笨蛋看着内存疯狂上涨吗？ 如果把vim和LSP结合在一起，岂不是双倍快乐？大项目不谈，写个小demo又会带来更多快乐。 neovim可以安装LSP，vim也可以，可惜后者似乎安装有些麻烦，还是前者吧，这也是我想从vim转到neovim的原因之一。 LSP插件组成 虽然叫LSP插件组成，这里实际是想讲整个LSP套件的组成，需要哪些插件。 LSP Server：刚才说了，我们想要的显示代码错误、代码补全建议的功能就是它提供的。 需要指出的是，不同的语言需要启用不同的LSP，比如C/CPP可以用Clangd，Go可以用gopls，Rust可以用rust-analyzer，Python可以用pyright。 需要安装。 LSP Client：大概是处理Server发来的信息呗，这部分不用管，neovim自带整个功能。 不需要安装。 LSP Server管理器：一个neovim插件，可以方便的管理各种LSP Server。 需要安装。 LSP Server下载器：neovim\u0026rsquo;插件，提供下载LSP Server功能。 需要安装。 代码补全建议插件：neovim不带这部分，LSP Server也不包含这部分，所以需要额外下一个neovim插件： 需要安装。 放到今天的示例里，对应关系为： LSP Server：按需下载，列表在nvim-lspconfig的文档 。 LSP Server管理器：nvim-lspconfig 。 LSP Server下载器：mason.vim 。 代码补全建议插件：nvim-cmp 。 最后提供一个示例：realth000/config "],["Hello_hugo","2023年01月01日","/en-us/2023/01/09/hello_hugo.html/","Hello Hugo"]]