[["Qt多语言翻译（国际化）","2023年01月01日","/en-us/2023/01/12/qt%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%BF%BB%E8%AF%91%E5%9B%BD%E9%99%85%E5%8C%96.html/","如果想支持多语言，也就是添加翻译，需要使用qlinguist相关的内容。 在qt中实现的大体流程为：根据源代码生成 `文件（翻译文件）。 源码中所有希望添加进翻译文件的字符串都需要使用 `包裹。 由于与涉及到不同的build system以及 `文件的加载方式，具体的实现方法非常乱。 梳理花了很大一番功夫。 以下学习过程基于flameshot\r和qBittorrent\r两个项目。 由于缺包等原因，我本地的环境没法编译qBittorrent工程，仅看源码来学习。 实现方式\r翻译文件的加载方式\r在翻译文件 `的加载方式上，有两个选择： 可以选择把文件单独放到一个文件夹（如 `）。 也可以选择放进资源文件 `）。 前者的好处是翻译文件独立，修改翻译文件时不需要重新编译程序，坏处是翻译文件暴露在外，可能会遇到丢失、乱码等情况。更常见的情况是修改并生成文件后，忘了把新版的文件放到 `文件夹里。 后者的好处是可以使用qrc资源系统控制，不暴露在外，只要重新生成即可不需要手动放到translation文件夹，坏处是一旦修改文件就需要重新编译程序，而且包含所有翻译语言的翻译文件的话程序体积会略微大一点。 两套构建系统对翻译文件的处理\rCMake\r在CMake里，如果想加载翻译文件，需要 `模块： 幸运的是 `模块不是一个单独的动态库，应该是包含在Qt5Core内的。 生成并加载翻译文件需要使用 `打开。 QMake\rQMake需要使用Qt的 `文件，其实CMake底层也是调用的这个工具。 加载翻译文件需要用INSTALLATIONS变量 += 上所有的 `文件。 希望尽可能的自动化\r编译过程需要手动操作的话非常恶星，总是希望整个构建过程能自动化就自动化。 需要自动化的点有： 自动根据 `。 自动加载 `能自动放在需要它的位置上，同时还包括程序加载翻译文件时选择当前系统语言。当然也可以加一个选择语言的配置，但能够选择性的加载翻译文件同样是必须的。 两个示例项目做了什么\rflameshot\rflameshot\r只支持CMake构建，对翻译文件的整个处理也比较简单。 在 `： 紧接着生成翻译文件： 根据 `本身只是一个手动控制的开关： 最后安装翻译文件到指定位置： 加载翻译文件的方式如下： 用了两个translator，一个加载Qt自带语句的翻译，一个是加载项目自己加入的需要的翻译。 qBittorrent\rqBittorrent\r同时支持使用QMake和Cmake构建，对翻译的处理较为复杂。 CMake\r在 `文件并生成翻译文件： `是qBittorrent自定义的一个函数，反正非常复杂就对了，杀鸡焉用牛刀，撤。 QMake\r在 `中，仅有以下几行代码即可： 最前面的一个大的if来设定生成翻译文件所用的 `两个变量。 非常简单明了。 最终实现\r选择的实现方法\r尽量想同时用QMake和CMake支持加载翻译文件，毕竟QMake有时候还挺好用，你Qt6的QMake停止更新关我Qt5的用户什么事。 选择将翻译文件放到 `文件里写自定义命令的方式安装到translation文件夹里，调用起来也麻烦。 预备工作\r首次生成翻译文件时，我们是连 `： 在源码里配置好想加入翻译文件的文本，包括 `包裹。 在 `文件里加上qBittorrent里翻译文件相关的配置 打开Qt自带的命令行，在这个命令行里才能用 `一下就行）。 使用 `。 用文本编辑器打开 `。 在打开刚出的命令行，用 `。 新建一个qrc文件（如 `也可以加进去，不加也行但要记得加进git仓库。 CMake\r在有 `添加进编译的目标程序内（格式不支持）： 注意： 以上语句需要在 `添加了qrc文件之前。 `设置的输出目录必须是qrc文件内记录的qm文件目录，否则生成时无法更新qrc文件内包含的翻译。 之后在 `时加上生成的翻译文件： 别忘了讲qrc文件加进来，并且打开AUTORCC开关： QMake\r`文件里加入以下配置： 完事了，非常简单。 加载翻译文件\r在 `之前，一般在main.cpp里： 我只制作了中文和英文两种翻译所以switch只有两条分支。 `需要在声明application之后。 "],["CMake实践记录","2023年01月01日","/en-us/2023/01/10/cmake%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95.html/","作为一门比shell的语法还x疼的“语言”，不动动笔杆子真不行。 以下基本以flameshot\r为例来学习。 覆盖掉CMakeCache中缓存的option\r不推荐使用 `，因为更改option状态时会被CMakeCache里的旧Option状态覆盖，且对subdirectory内的CMakeLists.txt作用效果不好。 推荐做法： `： OPTION_NAME：option名称。 OPTION_STATE：option状态，一般为 `，推荐使用全大写。 CACHE：表示写入到CMakeCache里。 FORCE：表示强制覆盖CMakeCache里的值。 CMakeLists.txt内添加编译时变量\r语法： ` 例如MSVC开启强制utf-8： 题外话，对应的在QMake内开启的方法为在 `内添加： 添加宏（MARCO）\r语法： ` 相当于编译时有了宏MARCO_NAME。 那么如何把宏去掉呢？ ` include、output、link的顺序\r先 `。 CMake使用Qt5库\r需要按以下几步走。 打开额外Compiler开关\r分别编译Qt的元对象系统（信号槽，或者说使用了 `。 设定CMake的Modules\r在尽量开头的位置设置 `到Qt自带的cmake目录，如： ` 实际操作过程中推荐这样写： ` 并在执行 `下： ` （Windows下，使用QtCreator不需要 `） 检查Qt库(CMake modules)的安装情况\r以使用QtCore、QtGui、QtWidgets为例，设定了 `后： ` PS：似乎还有一种语法： ` 链接Qt动态库\r基本在最后位置： ` 上面的语句默认链接debug版本的动态库，若要链接release版本，增加 ` ` 包含子目录\r在上层目录中，首先 ` 在子目录 ` target_sources的用法\r`（前提是相关Compiler已打开）。 区分系统平台\r立即推： QtCreator中could not load cache的解决方法\r可怜的qtc，bug满身，对Qml而言是，对CMake更是。 现在还坚持用qtc的原因只有方便看文档和上色丰富简单又好看了吧。 清除-重新构建后总是报错：could not load cache怎么办？ 找到左边项目-CMake- `，点一下即可重新编译。 Windows平台rc文件的使用\r使用 `添加即可。 注意：编码格式在设置了UTF-8以后无比不要用UTF-8-BOM，否则在编译时会报错。 关于 `文件的格式，参考flameshot.rc\rWindows平台关闭控制台\r使用 `参数： ` 解决Cannot find source file: main.cpp\r目录结构如下： CMakeLists一层一层add_subdirectory。 `时报错：Cannot find source file: main.cpp。 意外发现将CMake最低要求版本 `设置到\u0026gt;=3.13，qtc默认给的是3.5。 题外话：直接在文件夹里cmake .没有这个报错，所以……彩鸡qtc。 "],["配置neovim","2023年01月01日","/en-us/2023/01/09/%E9%85%8D%E7%BD%AEneovim.html/","\r配置neovim\rneovim\r是一款强大且轻量的基于vim的tui编辑器，相比vim有更现代的设置和插件系统。今天neovim的生态已然非常广泛。 安装neovim\rLinux\rneovim release page\r上提供了*.deb和*.tar.gz，安装非常方便。 不推荐通过 `等包管理软件安装neovim，版本太老。 Windows\rrelease page上提供了Windows可用的*.zip，使用Qt制作了GUI。 然而GUI太不vim了，想在Linux的shell里使用vim怎么办？可以采用wezterm + msys2 + 从源码编译neovim的组合技，可以复刻Linux shell中90%的操作。 编译方法见neovim wiki\r，大概命令如下： 亲测在Win10上一次编过，编完以后neovim的二进制会install到shell启动默认目录下的nvim-win64/bin内。找不到的话用Everything找一下就行了。加到PATH里即可顺利玩耍。 关于neovim插件\rSTOP！我说停停，到这里解释一下neovim插件相关的概念，为啥呢？网上教装插件的教程不少，但可能是我太笨吧，看完了也看得云里雾里，包括原生vim的插件也是很迷。 (neo)vim的插件\r插件指的是给(neo)vim提供额外功能的“软件”，一般是vimscript（适用于vim）和lua（适用于neovim）编写的，这两种都是脚本语言，下载插件也就是下载源码，一般从github上克隆到指定目录即可。 neovim也可以使用vimscript制作的插件，但是vimscript的效率比较低，装多了卡，而且远不如lua好理解，哪怕一点也不懂lua（比如我），看一看也能照猫画虎写，不推荐在neovim里用太多vimscript编写的插件。 (neo)vim的插件管理器\r插件管理器是指提供下载插件、管理插件加载的特殊插件，一般也是从github上安装，直接 `下来就行。 vim-plug\r是一款插件管理器，可以用于vim和neovim。在vim上算最好用的插件，但是在neovim里并不推荐，因为它用的是vimscript，和满处lua的neovim有点格格不入。 packer.vim\r也是一款插件管理器，可以用于neovim，采用lua编写，配置的可读性强，好上手，neovim上首推。 安装neovim插件\r安装packer.vim\r先安装插件管理器才方便装插件嘛，直接进行一个命令行的装： 至此，packer安装完成，那么如何通过它管理插件呢？ Linux上neovim会从 `读取配置，用lua写配置就是前者的路径了。 实际上配置路径好像很多，但是用这两个就行。 Windows的配置文件路径以后会补充，现在可以去官网看 先进到 `的文件夹，用来存放我们将要写的lua脚本。 把它想象成“项目根目录”，比如： 我写了一个 `。 没有这个文件夹就自己建一个。 看过一些neovim配置示例，按惯例： `，举个例子：\r`）加载vim基本配置，举个栗子： 相当于vim的 `里的： 不能说一模一样，只能说完全相同。 `）里面写想加载的插件及其配置，还是举例子： 写好配置了，然后怎么安装呢？ 运行 `即可自动从github上下载插件并把旧插件升到最新版本。 安装LSP\rneovim安装LSP比较方便，LSP是指\u0026quot;Language Server Protocol\u0026quot;，虽然是协议，可以理解为一种在后台进行静态代码分析的server，提供显示代码错误、代码补全建议的功能，非常好用。 Idea、VS Code太重了，难道我写个demo还要打开这些笨蛋看着内存疯狂上涨吗？ 如果把vim和LSP结合在一起，岂不是双倍快乐？大项目不谈，写个小demo又会带来更多快乐。 neovim可以安装LSP，vim也可以，可惜后者似乎安装有些麻烦，还是前者吧，这也是我想从vim转到neovim的原因之一。 LSP插件组成\r虽然叫LSP插件组成，这里实际是想讲整个LSP套件的组成，需要哪些插件。 LSP Server：刚才说了，我们想要的显示代码错误、代码补全建议的功能就是它提供的。 需要指出的是，不同的语言需要启用不同的LSP，比如C/CPP可以用Clangd，Go可以用gopls，Rust可以用rust-analyzer，Python可以用pyright。 需要安装。 LSP Client：大概是处理Server发来的信息呗，这部分不用管，neovim自带整个功能。 不需要安装。 LSP Server管理器：一个neovim插件，可以方便的管理各种LSP Server。 需要安装。 LSP Server下载器：neovim\u0026rsquo;插件，提供下载LSP Server功能。 需要安装。 代码补全建议插件：neovim不带这部分，LSP Server也不包含这部分，所以需要额外下一个neovim插件： 需要安装。 放到今天的示例里，对应关系为： LSP Server：按需下载，列表在nvim-lspconfig的文档\r。 LSP Server管理器：nvim-lspconfig\r。 LSP Server下载器：mason.vim\r。 代码补全建议插件：nvim-cmp\r。 最后提供一个示例：realth000/config\r"],["Hello_hugo","2023年01月01日","/en-us/2023/01/09/hello_hugo.html/","Hello Hugo"]]